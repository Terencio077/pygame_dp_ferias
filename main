# football_heads.py
import pygame
import os
import sys
import math
import random

# ------ Configurações ------
WIDTH, HEIGHT = 1000, 600
FPS = 60

GROUND_Y = HEIGHT - 80
GOAL_WIDTH = 140
SCORE_TO_WIN = 5

# Física
GRAVITY = 0.9
FRICTION = 0.995
BALL_FRICTION = 0.999
BALL_BOUNCE = 0.88
MAX_BALL_SPEED = 15.0    # velocidade máxima da bola (px/frame)
PLAYER_BOUNCE = 0.15  # restituição para colisão bola-jogador (menor = menos elástico)
BALL_GRAVITY_MULT = 0.9  # multiplicador de gravidade específico para a bola (era 0.45)
BALL_TOP_MARGIN = 40     # quanto acima da tela a bola pode subir (px)

# Cores
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (40, 180, 60)
BLUE = (60, 140, 220)
RED = (220, 60, 60)
YELLOW = (240, 200, 30)
DARK = (25, 25, 25)

pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Football Heads - Pygame Prototype")
clock = pygame.time.Clock()
font = pygame.font.SysFont("Arial", 28)

def try_load_image(name):
    # tenta carregar imagem buscando a partir do diretório deste arquivo
    base_dir = os.path.dirname(os.path.abspath(__file__))
    paths = [
        os.path.join(base_dir, name),
        os.path.join(base_dir, 'assets', name),
        os.path.join(base_dir, 'assets_futebol', name),
    ]
    for p in paths:
        if not os.path.exists(p):
            continue
        try:
            return pygame.image.load(p)
        except Exception:
            continue
    return None

# carregar imagem de fundo (arquivo 'plano de fundo.png' na raiz ou em assets)
_bg = try_load_image("plano de fundo.png")
if _bg:
    try:
        bg_image = pygame.transform.scale(_bg, (WIDTH, HEIGHT)).convert()
    except Exception:
        bg_image = _bg.convert()
else:
    bg_image = None

# se houver imagem de fundo, ajusta o chão para ficar próximo ao fim da imagem
if bg_image:
    GROUND_Y = HEIGHT - 20

# carregar sprites dos jogadores (fallback para desenho se não existirem)
_p_blue = try_load_image("Player Blu.png") or try_load_image("Player Blu.png" )
if _p_blue:
    try:
        _p_blue = _p_blue.convert_alpha()
    except Exception:
        _p_blue = _p_blue.convert()
    target_h = int(40 * 2.2)
    _w = int(_p_blue.get_width() * (target_h / _p_blue.get_height()))
    PLAYER_BLUE_IMG = pygame.transform.scale(_p_blue, (_w, target_h))
else:
    PLAYER_BLUE_IMG = None

_p_red = try_load_image("Player Red.png")
if _p_red:
    try:
        _p_red = _p_red.convert_alpha()
    except Exception:
        _p_red = _p_red.convert()
    target_h = int(40 * 2.2)
    _w = int(_p_red.get_width() * (target_h / _p_red.get_height()))
    PLAYER_RED_IMG = pygame.transform.scale(_p_red, (_w, target_h))
else:
    PLAYER_RED_IMG = None

# carregar sprites das pernas (fallbacks: flip quando necessário)
_p_b_left = try_load_image("Player blu left leg.png")
if _p_b_left:
    try:
        _p_b_left = _p_b_left.convert_alpha()
    except Exception:
        _p_b_left = _p_b_left.convert()
    PLAYER_BLUE_LEG_LEFT = pygame.transform.scale(_p_b_left, (int(_p_b_left.get_width()*1.0), int(_p_b_left.get_height()*1.0)))
else:
    PLAYER_BLUE_LEG_LEFT = None
_p_b_right = try_load_image("Player blu right leg.png")
if _p_b_right:
    try:
        _p_b_right = _p_b_right.convert_alpha()
    except Exception:
        _p_b_right = _p_b_right.convert()
    PLAYER_BLUE_LEG_RIGHT = pygame.transform.scale(_p_b_right, (int(_p_b_right.get_width()*1.0), int(_p_b_right.get_height()*1.0)))
else:
    PLAYER_BLUE_LEG_RIGHT = pygame.transform.flip(PLAYER_BLUE_LEG_LEFT, True, False) if PLAYER_BLUE_LEG_LEFT else None

_p_r_left = try_load_image("Player red left leg.png")
if _p_r_left:
    try:
        _p_r_left = _p_r_left.convert_alpha()
    except Exception:
        _p_r_left = _p_r_left.convert()
    PLAYER_RED_LEG_LEFT = pygame.transform.scale(_p_r_left, (int(_p_r_left.get_width()*1.0), int(_p_r_left.get_height()*1.0)))
else:
    PLAYER_RED_LEG_LEFT = None
PLAYER_RED_LEG_RIGHT = pygame.transform.flip(PLAYER_RED_LEG_LEFT, True, False) if PLAYER_RED_LEG_LEFT else None

# debug: report quais sprites foram carregadas
print("Sprite load status:")
print("  PLAYER_BLUE_IMG:", PLAYER_BLUE_IMG is not None)
print("  PLAYER_RED_IMG:", PLAYER_RED_IMG is not None)
print("  PLAYER_BLUE_LEG_LEFT:", PLAYER_BLUE_LEG_LEFT is not None)
print("  PLAYER_BLUE_LEG_RIGHT:", PLAYER_BLUE_LEG_RIGHT is not None)
print("  PLAYER_RED_LEG_LEFT:", PLAYER_RED_LEG_LEFT is not None)
print("  PLAYER_RED_LEG_RIGHT:", PLAYER_RED_LEG_RIGHT is not None)

# carregar imagem da bola (assets_futebol/football.png ou football)
BALL_IMG = try_load_image("football.png") or try_load_image("football")
if BALL_IMG:
    try:
        BALL_IMG = BALL_IMG.convert_alpha()
    except Exception:
        BALL_IMG = BALL_IMG.convert()

# ------ Classes ------
class Ball:
    def __init__(self, x, y, r=16):
        self.x = x
        self.y = y
        self.r = r
        self.vx = 0.0
        self.vy = 0.0

    def update(self):
        # física simples (gravidade aplicada com multiplicador da bola)
        self.vy += GRAVITY * BALL_GRAVITY_MULT
        self.x += self.vx
        self.y += self.vy

        # limitar altura máxima: não permitir que a bola vá muito acima da tela
        if self.y - self.r < -BALL_TOP_MARGIN:
            self.y = -BALL_TOP_MARGIN + self.r
            if self.vy < 0:
                self.vy = 0.0

        # colisão com chão
        if self.y + self.r > GROUND_Y:
            self.y = GROUND_Y - self.r
            # mais elástico: usar coeficiente de restituição
            self.vy = -abs(self.vy) * BALL_BOUNCE
            self.vx *= BALL_FRICTION

        # colisão com paredes (mas permitir que bola entre nos gols)
        # gol esquerdo: não rebater se x < 10 e altura certa
        if self.x - self.r < 0:
            if not (self.x - self.r < 10 and GROUND_Y - 85 < self.y <= GROUND_Y):
                self.x = self.r
                self.vx = abs(self.vx) * 0.8
        
        # gol direito: não rebater se x > WIDTH-10 e altura certa
        if self.x + self.r > WIDTH:
            if not (self.x + self.r > WIDTH - 10 and GROUND_Y - 85 < self.y <= GROUND_Y):
                self.x = WIDTH - self.r
                self.vx = -abs(self.vx) * 0.8

        # colisão com o teto da janela (se bater no topo)
        if self.y - self.r < 0:
            self.y = self.r
            self.vy = abs(self.vy) * BALL_BOUNCE

        # leve resistência
        self.vx *= BALL_FRICTION
        if abs(self.vx) < 0.01:
            self.vx = 0.0
        if abs(self.vy) < 0.01 and self.y + self.r >= GROUND_Y - 0.5:
            self.vy = 0.0
        
        # limitar velocidade máxima da bola
        speed = math.hypot(self.vx, self.vy)
        if speed > MAX_BALL_SPEED:
            scale = MAX_BALL_SPEED / speed
            self.vx *= scale
            self.vy *= scale

    def check_stuck_between_players(self, p1, p2):
        # verifica se a bola está presa horizontalmente entre os dois jogadores
        left_player = p1 if p1.x < p2.x else p2
        right_player = p2 if p1.x < p2.x else p1
        
        # se bola está entre eles horizontalmente
        if left_player.x < self.x < right_player.x:
            # distância para cada um
            dist_left = abs(self.x - left_player.x)
            dist_right = abs(self.x - right_player.x)
            # se muito próximo a ambos (preso) - MUITO sensível
            if dist_left < left_player.head_radius + 30 and dist_right < right_player.head_radius + 30:
                # colocar acima de ambos
                self.y = min(left_player.y, right_player.y) - 60
                # aplicar velocidade para cima com força MUITO maior
                self.vy = -25.0
                # dispersão horizontal forte
                self.vx = (8.0 if random.random() > 0.5 else -8.0) + random.uniform(-3, 3)

    def draw(self, surf):
        # se houver imagem carregada, usa a imagem (`assets_futebol/football`)
        if 'BALL_IMG' in globals() and BALL_IMG:
            try:
                img = pygame.transform.smoothscale(BALL_IMG, (int(self.r * 2), int(self.r * 2)))
            except Exception:
                img = pygame.transform.scale(BALL_IMG, (int(self.r * 2), int(self.r * 2)))
            rect = img.get_rect(center=(int(self.x), int(self.y)))
            surf.blit(img, rect)
            return

        # desenha bola com padrão clássico: hexágonos/pentágonos pretos e brancos (fallback)
        w = self.r * 2 + 6
        h = w
        ball_surf = pygame.Surface((w, h), pygame.SRCALPHA)
        cx, cy = w // 2, h // 2

        # base branca
        pygame.draw.circle(ball_surf, (255, 255, 255), (cx, cy), self.r)

        # helper: polígono regular
        def regular_poly(x, y, rad, sides, rot=0.0):
            pts = []
            for i in range(sides):
                a = rot + i * (2 * math.pi / sides)
                pts.append((int(x + math.cos(a) * rad), int(y + math.sin(a) * rad)))
            return pts

        # centro: pequeno pentágono preto
        center_rad = int(self.r * 0.26)
        center_pts = regular_poly(cx, cy, center_rad, 5, math.radians(-18))
        pygame.draw.polygon(ball_surf, (0, 0, 0), center_pts)

        # hexágonos ao redor (6 ao redor do pentágono) - cores alternadas
        ring_dist = int(self.r * 0.58)
        hex_rad = int(self.r * 0.28)
        for k in range(6):
            ang = k * (2 * math.pi / 6)
            px = cx + int(math.cos(ang) * ring_dist)
            py = cy + int(math.sin(ang) * ring_dist)
            pts = regular_poly(px, py, hex_rad, 6, ang + math.radians(30))
            fill_color = WHITE if (k % 2 == 0) else BLACK
            pygame.draw.polygon(ball_surf, fill_color, pts)
            if fill_color == WHITE:
                pygame.draw.polygon(ball_surf, BLACK, pts, 1)

        surf.blit(ball_surf, (int(self.x - cx), int(self.y - cy)))

class Player:
    def __init__(self, x, color, controls, image=None):
        self.x = x
        self.y = GROUND_Y - 40
        self.vx = 0.0
        self.vy = 0.0
        self.radius = 18
        self.head_radius = 23  # aumentado para incluir cabelo na colisão
        self.color = color
        self.speed = 5.0
        self.on_ground = True
        self.facing = 1  # 1 = direita, -1 = esquerda
        self.controls = controls
        self.score = 0
        self.kick_cooldown = 0
        self.image = image
        # pernas e animação de chute
        if self.color == BLUE:
            self.left_leg_img = PLAYER_BLUE_LEG_LEFT
            self.right_leg_img = PLAYER_BLUE_LEG_RIGHT
        else:
            self.left_leg_img = PLAYER_RED_LEG_LEFT
            self.right_leg_img = PLAYER_RED_LEG_RIGHT
        self.kick_timer = 0
        self.kick_duration = 12
        self.kick_side = None
        # animação da perna (apenas durante o chute)
        self.front_leg_scale = 4.8
        self.leg_phase = 0.0
        self.image = image

    def rect(self):
        # corpo rectangle for collisions
        return pygame.Rect(self.x - self.head_radius, self.y - self.head_radius, self.head_radius*2, self.head_radius*2)

    def update(self, keys):
        # movimento lateral
        moving_left = keys[self.controls['left']]
        moving_right = keys[self.controls['right']]
        if moving_left and not moving_right:
            self.vx = -self.speed
            self.facing = -1
        if moving_right and not moving_left:
            self.vx = self.speed
            self.facing = 1
        if not moving_left and not moving_right:
            self.vx *= 0.85
            if abs(self.vx) < 0.1:
                self.vx = 0.0

        # pulo
        if keys[self.controls['jump']] and self.on_ground:
            self.vy = -14.5
            self.on_ground = False

        # aplicar física
        self.vy += GRAVITY * 0.9
        self.x += self.vx
        self.y += self.vy

        # chão
        if self.y + self.head_radius > GROUND_Y:
            self.y = GROUND_Y - self.head_radius
            self.vy = 0.0
            self.on_ground = True

        # limites da tela (permite sair um pouco pra perto do gol)
        min_x = 10
        max_x = WIDTH - 10
        if self.x < min_x:
            self.x = min_x
            self.vx = 0.0
        if self.x > max_x:
            self.x = max_x
            self.vx = 0.0

        # cooldown do chute
        if self.kick_cooldown > 0:
            self.kick_cooldown -= 1
        # atualizar timer da animação de perna
        if self.kick_timer > 0:
            self.kick_timer -= 1
        else:
            self.kick_side = None
        # animação da perna é atualizada somente quando em kick (kick_timer)
        if self.kick_timer > 0:
            # small phase advance to drive sinusoidal kick curve
            self.leg_phase = (self.leg_phase + 0.3) if hasattr(self, 'leg_phase') else 0.3

    def draw(self, surf):
        # desenho por sprite se disponível (com pernas)
        if self.image:
            hip_x = int(self.x)
            hip_y = int(self.y + self.head_radius * 0.5)

            # animação de chute
            if self.kick_timer > 0:
                t = (self.kick_duration - self.kick_timer) / max(1, self.kick_duration)
                max_angle = 65
                angle = -math.sin(t * math.pi) * max_angle
            else:
                angle = 0

            # body sprite (desenhar primeiro para calcular posição)
            img = self.image
            if self.facing == -1:
                img = pygame.transform.flip(self.image, True, False)
            rect = img.get_rect()
            rect.midbottom = (int(self.x), int(self.y + self.head_radius))
            surf.blit(img, rect)

            # recalcula posição do quadril com base no sprite para posicionar perna frontal
            hip_x = rect.centerx
            hip_y = rect.bottom - int(self.head_radius * 0.2)

            # apenas a perna da frente (dependendo da direção do jogador)
            front_side = 'right' if self.facing == 1 else 'left'
            front_img = self.right_leg_img if front_side == 'right' else self.left_leg_img

            # parâmetros de escala/offset para perna maior e deslocada
            leg_scale = self.front_leg_scale
            leg_offset_x = int(self.head_radius * 0.95) * self.facing
            leg_offset_y = int(self.head_radius * 0.05)

            # animação de chute: apenas quando kick_timer ativo
            if self.kick_timer > 0:
                t = (self.kick_duration - self.kick_timer) / max(1, self.kick_duration)
                max_angle = 90
                kick_ang = -math.sin(t * math.pi) * max_angle
            else:
                kick_ang = 0
            ang_total = kick_ang

            if front_img:
                # flip simples quando estiver virado para a esquerda
                img_blit = pygame.transform.flip(front_img, True, False) if self.facing == -1 else front_img
                rotation_angle = -ang_total * self.facing
                rot = pygame.transform.rotozoom(img_blit, rotation_angle, leg_scale)
                r = rot.get_rect(center=(hip_x + leg_offset_x, hip_y + leg_offset_y))
                surf.blit(rot, r)
            else:
                # fallback: cria superfície retangular para perna e rotaciona
                leg_w = max(18, int(self.head_radius * 0.8))
                leg_h = max(48, int(self.head_radius * 2.0))
                leg_surf = pygame.Surface((leg_w, leg_h), pygame.SRCALPHA)
                pygame.draw.rect(leg_surf, self.color, (0, 0, leg_w, leg_h))
                rotation_angle = -ang_total * self.facing
                rot = pygame.transform.rotozoom(leg_surf, rotation_angle, leg_scale)
                r = rot.get_rect(center=(hip_x + leg_offset_x, hip_y + leg_offset_y))
                surf.blit(rot, r)
            return

        # fallback: desenho simples (corpo + cabeça + olhos)
        body_rect = pygame.Rect(int(self.x - 18), int(self.y), 36, int(self.head_radius*0.9))
        pygame.draw.rect(surf, self.color, body_rect)
        pygame.draw.circle(surf, self.color, (int(self.x), int(self.y - 6)), self.head_radius)
        eye_x = int(self.x + self.facing * 10)
        pygame.draw.circle(surf, WHITE, (eye_x - 8, int(self.y - 12)), 6)
        pygame.draw.circle(surf, WHITE, (eye_x + 8, int(self.y - 12)), 6)
        pygame.draw.circle(surf, BLACK, (eye_x - 8, int(self.y - 12)), 3)
        pygame.draw.circle(surf, BLACK, (eye_x + 8, int(self.y - 12)), 3)

    def try_kick(self, ball, keys, kick_type='kick'):
        # chute quando aperta a tecla (normal ou lob)
        if kick_type not in self.controls or not keys[self.controls[kick_type]]:
            return
        if self.kick_cooldown == 0:
            # iniciar animação de chute sempre que tecla for pressionada
            self.kick_timer = self.kick_duration
            self.kick_side = 'right' if self.facing == 1 else 'left'
            # aplica cooldown imediatamente para evitar reinício contínuo
            self.kick_cooldown = 18

            # aplicar impulso somente se estiver no alcance
            dx = ball.x - self.x
            dy = ball.y - self.y
            dist = math.hypot(dx, dy)
            if dist < self.head_radius + ball.r + 15:  # alcance aumentado
                if kick_type == 'lob':
                    # lançamento oblíquo: força maior e ângulo MUITO ascendente
                    force = 16.0
                    nx = dx / (dist + 1e-6)
                    ny = dy / (dist + 1e-6)
                    ball.vx += nx * force + self.facing * 2.0
                    ball.vy += ny * force - 16.0  # MUITO mais ascendente
                else:
                    # chute normal: força aumentada
                    force = 18.0
                    nx = dx / (dist + 1e-6)
                    ny = dy / (dist + 1e-6)
                    ball.vx += nx * force + self.facing * 4.0
                    ball.vy += ny * force - 3.0

    def try_headbutt(self, ball, keys, kick_type='kick'):
        # cabeceio: acionado quando a bola está acima e próxima
        if kick_type not in self.controls or not keys[self.controls[kick_type]]:
            return
        
        dx = ball.x - self.x
        dy = ball.y - (self.y - self.head_radius * 0.5)
        dist = math.hypot(dx, dy)
        
        # cabeceio só funciona se bola está acima e próxima
        if dy < -5 and dist < self.head_radius + ball.r + 12 and self.kick_cooldown == 0:
            self.kick_timer = self.kick_duration
            self.kick_side = 'right' if self.facing == 1 else 'left'
            self.kick_cooldown = 18
            
            # força de cabeceio (mais forte que chute normal, menos que lob)
            force = 17.0
            nx = dx / (dist + 1e-6)
            ny = dy / (dist + 1e-6)
            
            if kick_type == 'lob':
                # cabeceio em lob: ângulo de 45 graus
                ball.vx += nx * force + self.facing * 3.0
                ball.vy += ny * force - 10.0
            else:
                # cabeceio normal: tira a bola com força
                ball.vx += nx * force + self.facing * 3.0
                ball.vy += ny * force - 5.0
                # iniciar animação de chute: escolhe perna conforme direção
                self.kick_timer = self.kick_duration
                self.kick_side = 'right' if self.facing == 1 else 'left'

# ------ Funções utilitárias ------
def circle_collision(player, ball):
    dx = ball.x - player.x
    dy = ball.y - (player.y - player.head_radius * 0.7)  # melhor cobertura da altura da cabeça
    dist = math.hypot(dx, dy)
    min_dist = player.head_radius + ball.r
    
    # detectar colisão com margem MUITO maior
    if dist < min_dist and dist > 0.1:
        overlap = min_dist - dist
        nx = dx / dist
        ny = dy / dist
        
        # empurra bola para MUITO longe e de forma agressiva
        push_distance = max(overlap * 2.0 + 5, player.head_radius * 0.3)
        ball.x += nx * push_distance
        ball.y += ny * push_distance
        
        # garantir que bola sai completamente
        attempts = 0
        while math.hypot(ball.x - player.x, ball.y - (player.y - 6)) < min_dist * 1.05 and attempts < 10:
            ball.x += nx * 2
            ball.y += ny * 2
            attempts += 1
        
        # resposta elástica: aplicar impulso ao longo da normal
        rel_vel_norm = (ball.vx - player.vx) * nx + (ball.vy - player.vy) * ny
        
        # se estiverem se aproximando, aplica restituição
        if rel_vel_norm < 0:
            e = PLAYER_BOUNCE * 1.2
            impulse = -(1 + e) * rel_vel_norm * 0.6
            ball.vx += impulse * nx
            ball.vy += impulse * ny
        
        # transferência mínima do movimento do jogador
        ball.vx += player.vx * 0.08
        ball.vy += player.vy * 0.08


def resolve_player_collision(p1, p2):
    # resolve overlap between two players and apply small pushing impulse
    dx = p2.x - p1.x
    dy = (p2.y - 6) - (p1.y - 6)  # usar mesmo ponto de colisão que circle_collision
    dist = math.hypot(dx, dy)
    min_dist = p1.head_radius + p2.head_radius
    if dist == 0:
        # separate slightly to avoid division by zero
        dx = 1.0
        dist = 1.0
    if dist < min_dist:
        overlap = min_dist - dist
        nx = dx / dist
        ny = dy / dist
        # push players apart with extra separation to prevent overlap
        push_x = nx * (overlap + 2)
        push_y = ny * (overlap + 2)
        p1.x -= push_x
        p1.y -= push_y
        p2.x += push_x
        p2.y += push_y

        # apply small impulse along normal so they 'push' each other
        rel_vel = (p2.vx - p1.vx) * nx + (p2.vy - p1.vy) * ny
        if rel_vel < 0:
            e = 0.2  # low restitution between players
            impulse = -(1 + e) * rel_vel * 0.5
            p1.vx -= impulse * nx
            p1.vy -= impulse * ny
            p2.vx += impulse * nx
            p2.vy += impulse * ny
        # garantir que nenhum jogador fique enterrado no chão após o ajuste
        if p1.y + p1.head_radius > GROUND_Y:
            p1.y = GROUND_Y - p1.head_radius
            p1.vy = 0.0
            p1.on_ground = True
        if p2.y + p2.head_radius > GROUND_Y:
            p2.y = GROUND_Y - p2.head_radius
            p2.vy = 0.0
            p2.on_ground = True

def draw_field(surf):
    # desenha imagem de fundo se disponível; caso contrário, pinta verde simples
    if bg_image:
        surf.blit(bg_image, (0, 0))
    else:
        surf.fill(GREEN)

def check_goal(ball, players):
    # gol esquerdo - zona de detecção apenas na altura do gol
    if ball.x - ball.r <= 10 and GROUND_Y - 85 < ball.y <= GROUND_Y:
        return 'right'  # gol do time da direita
    # gol direito - zona de detecção apenas na altura do gol
    if ball.x + ball.r >= WIDTH - 10 and GROUND_Y - 85 < ball.y <= GROUND_Y:
        return 'left'
    return None

def reset_positions(ball, p1, p2):
    ball.x = WIDTH // 2
    ball.y = HEIGHT // 2 - 30
    ball.vx = random.choice([-3, 3])
    ball.vy = -4
    p1.x = WIDTH * 0.25
    p1.y = GROUND_Y - p1.head_radius
    p1.vx = p1.vy = 0
    p2.x = WIDTH * 0.75
    p2.y = GROUND_Y - p2.head_radius
    p2.vx = p2.vy = 0

# ------ Inicialização do jogo ------
ball = Ball(WIDTH//2, HEIGHT//2 - 50)
controls_p1 = {'left': pygame.K_a, 'right': pygame.K_d, 'jump': pygame.K_w, 'kick': pygame.K_s, 'lob': pygame.K_x}
controls_p2 = {'left': pygame.K_LEFT, 'right': pygame.K_RIGHT, 'jump': pygame.K_UP, 'kick': pygame.K_DOWN, 'lob': pygame.K_m}

p1 = Player(WIDTH * 0.25, BLUE, controls_p1, image=PLAYER_BLUE_IMG)
p2 = Player(WIDTH * 0.75, RED, controls_p2, image=PLAYER_RED_IMG)

reset_positions(ball, p1, p2)

# ------ Loop principal ------
running = True
paused = False
goal_cooldown = 0

while running:
    dt = clock.tick(FPS)
    keys = pygame.key.get_pressed()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                pygame.quit()
                sys.exit()
            if event.key == pygame.K_SPACE:
                paused = not paused

    if not paused:
        # atualizar jogadores
        p1.update(keys)
        p2.update(keys)
        # resolver colisão jogador-jogador para que se empurrem
        resolve_player_collision(p1, p2)

        # atualizar bola
        ball.update()
        # verificar se bola ficou presa entre jogadores
        ball.check_stuck_between_players(p1, p2)

        # colisões bola-jogador
        circle_collision(p1, ball)
        circle_collision(p2, ball)

        # chutar (normal e lob) e cabeceio
        p1.try_kick(ball, keys, 'kick')
        p1.try_kick(ball, keys, 'lob')
        p1.try_headbutt(ball, keys, 'kick')
        p1.try_headbutt(ball, keys, 'lob')
        p2.try_kick(ball, keys, 'kick')
        p2.try_kick(ball, keys, 'lob')
        p2.try_headbutt(ball, keys, 'kick')
        p2.try_headbutt(ball, keys, 'lob')

        # checar gol
        if goal_cooldown == 0:
            scorer = check_goal(ball, (p1, p2))
            if scorer == 'right':
                p2.score += 1
                ball.vx *= 0.3  # frear a bola
                ball.vy *= 0.3
                goal_cooldown = FPS * 3  # 3 segundos de pausa
                reset_positions(ball, p1, p2)
            elif scorer == 'left':
                p1.score += 1
                ball.vx *= 0.3  # frear a bola
                ball.vy *= 0.3
                goal_cooldown = FPS * 3  # 3 segundos de pausa
                reset_positions(ball, p1, p2)
        else:
            goal_cooldown -= 1

    # desenho
    draw_field(screen)
    # (remoção das marcações desenhadas; apenas plano de fundo agora)

    p1.draw(screen)
    p2.draw(screen)
    ball.draw(screen)

    # HUD: placar
    score_text = font.render(f"{p1.score}  -  {p2.score}", True, BLACK)
    screen.blit(score_text, (WIDTH//2 - score_text.get_width()//2, 18))

    # instruções removidas: HUD fica apenas com placar e pausa

    if paused:
        pause_txt = font.render("PAUSADO", True, BLACK)
        screen.blit(pause_txt, (WIDTH//2 - pause_txt.get_width()//2, HEIGHT//2 - 20))

    pygame.display.flip()

    # checar vitória
    if p1.score >= SCORE_TO_WIN or p2.score >= SCORE_TO_WIN:
        winner = "Azul" if p1.score > p2.score else "Vermelho"
        end_txt = font.render(f"{winner} venceu! Aperte ESC para sair.", True, BLACK)
        screen.blit(end_txt, (WIDTH//2 - end_txt.get_width()//2, HEIGHT//2 + 40))
        pygame.display.flip()
        # espera até o usuário fechar (loop simples)
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
