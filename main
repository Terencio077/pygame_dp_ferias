# football_heads.py
import pygame
import os
import sys
import math
import random
import tela  # - Importa o arquivo da tela de menu

# ------ Configurações ------
WIDTH, HEIGHT = 1000, 600
FPS = 60

GROUND_Y = HEIGHT - 80
GOAL_WIDTH = 140
SCORE_TO_WIN = 5

# Física
GRAVITY = 0.9
FRICTION = 0.995
BALL_FRICTION = 0.999
BALL_BOUNCE = 0.88
MAX_BALL_SPEED = 15.0    # velocidade máxima da bola (px/frame)
PLAYER_BOUNCE = 0.15     # restituição para colisão bola-jogador
BALL_GRAVITY_MULT = 0.9  # multiplicador de gravidade específico para a bola
BALL_TOP_MARGIN = 40     # quanto acima da tela a bola pode subir (px)

# Cores
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (40, 180, 60)
BLUE = (60, 140, 220)
RED = (220, 60, 60)
YELLOW = (240, 200, 30)
DARK = (25, 25, 25)

pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Football Heads - Pygame Prototype")
clock = pygame.time.Clock()
font = pygame.font.SysFont("Arial", 28)

def try_load_image(name):
    # tenta carregar imagem pelo nome direto, assets/ e assets_futebol/
    paths = [name, os.path.join('assets', name), os.path.join('assets_futebol', name)]
    for p in paths:
        try:
            return pygame.image.load(p)
        except Exception:
            continue
    return None

# Carregamento de Sprites e Fundo
_bg = try_load_image("plano de fundo.png")
if _bg:
    try:
        bg_image = pygame.transform.scale(_bg, (WIDTH, HEIGHT)).convert()
    except Exception:
        bg_image = _bg.convert()
else:
    bg_image = None

if bg_image:
    GROUND_Y = HEIGHT - 20

_p_blue = try_load_image("Player Blu.png")
if _p_blue:
    try:
        _p_blue = _p_blue.convert_alpha()
    except Exception:
        _p_blue = _p_blue.convert()
    target_h = int(40 * 2.2)
    _w = int(_p_blue.get_width() * (target_h / _p_blue.get_height()))
    PLAYER_BLUE_IMG = pygame.transform.scale(_p_blue, (_w, target_h))
else:
    PLAYER_BLUE_IMG = None

_p_red = try_load_image("Player Red.png")
if _p_red:
    try:
        _p_red = _p_red.convert_alpha()
    except Exception:
        _p_red = _p_red.convert()
    target_h = int(40 * 2.2)
    _w = int(_p_red.get_width() * (target_h / _p_red.get_height()))
    PLAYER_RED_IMG = pygame.transform.scale(_p_red, (_w, target_h))
else:
    PLAYER_RED_IMG = None

# Pernas
_p_b_left = try_load_image("Player blu left leg.png")
if _p_b_left:
    try:
        _p_b_left = _p_b_left.convert_alpha()
    except Exception:
        _p_b_left = _p_b_left.convert()
    PLAYER_BLUE_LEG_LEFT = pygame.transform.scale(_p_b_left, (_p_b_left.get_width(), _p_b_left.get_height()))
else:
    PLAYER_BLUE_LEG_LEFT = None

_p_b_right = try_load_image("Player blu right leg.png")
if _p_b_right:
    try:
        _p_b_right = _p_b_right.convert_alpha()
    except Exception:
        _p_b_right = _p_b_right.convert()
    PLAYER_BLUE_LEG_RIGHT = pygame.transform.scale(_p_b_right, (_p_b_right.get_width(), _p_b_right.get_height()))
else:
    PLAYER_BLUE_LEG_RIGHT = pygame.transform.flip(PLAYER_BLUE_LEG_LEFT, True, False) if PLAYER_BLUE_LEG_LEFT else None

_p_r_left = try_load_image("Player red left leg.png")
if _p_r_left:
    try:
        _p_r_left = _p_r_left.convert_alpha()
    except Exception:
        _p_r_left = _p_r_left.convert()
    PLAYER_RED_LEG_LEFT = pygame.transform.scale(_p_r_left, (_p_r_left.get_width(), _p_r_left.get_height()))
else:
    PLAYER_RED_LEG_LEFT = None

PLAYER_RED_LEG_RIGHT = pygame.transform.flip(PLAYER_RED_LEG_LEFT, True, False) if PLAYER_RED_LEG_LEFT else None

# Bola
_ball = try_load_image("ball.png") or try_load_image("bola.png")
if _ball:
    try:
        _ball = _ball.convert_alpha()
    except Exception:
        _ball = _ball.convert()
    BALL_IMG = pygame.transform.smoothscale(_ball, (38, 38))
else:
    BALL_IMG = None

# ------ Classes ------
class Ball:
    def __init__(self, x, y, r=18):
        self.x = x
        self.y = y
        self.r = r
        self.vx = 0.0
        self.vy = 0.0

    def update(self):
        self.vy += GRAVITY * BALL_GRAVITY_MULT
        self.x += self.vx
        self.y += self.vy

        if self.y - self.r < -BALL_TOP_MARGIN:
            self.y = -BALL_TOP_MARGIN + self.r
            if self.vy < 0: self.vy = 0.0

        if self.y + self.r > GROUND_Y:
            self.y = GROUND_Y - self.r
            self.vy = -abs(self.vy) * BALL_BOUNCE
            self.vx *= BALL_FRICTION

        if self.x - self.r < 0:
            self.x = self.r
            self.vx = abs(self.vx) * 0.8
        if self.x + self.r > WIDTH:
            self.x = WIDTH - self.r
            self.vx = -abs(self.vx) * 0.8

        if self.y - self.r < 0:
            self.y = self.r
            self.vy = abs(self.vy) * BALL_BOUNCE

        # Colisão trave superior
        crossbar_y = GROUND_Y - 110
        goal_zone_width = 160
        if (self.y - self.r <= crossbar_y) and (self.x < goal_zone_width or self.x > WIDTH - goal_zone_width):
            self.y = crossbar_y + self.r
            self.vy = abs(self.vy) * BALL_BOUNCE * 1.2
            self.vx *= 0.75

        self.vx *= BALL_FRICTION
        speed = math.hypot(self.vx, self.vy)
        if speed > MAX_BALL_SPEED:
            scale = MAX_BALL_SPEED / speed
            self.vx *= scale
            self.vy *= scale

    def check_stuck_between_players(self, p1, p2):
        left_player = p1 if p1.x < p2.x else p2
        right_player = p2 if p1.x < p2.x else p1
        if left_player.x < self.x < right_player.x:
            dist_left = abs(self.x - left_player.x)
            dist_right = abs(self.x - right_player.x)
            if dist_left < left_player.head_radius + 30 and dist_right < right_player.head_radius + 30:
                self.y = min(left_player.y, right_player.y) - 60
                self.vy = -25.0
                self.vx = (8.0 if random.random() > 0.5 else -8.0) + random.uniform(-3, 3)

    def draw(self, surf):
        if BALL_IMG:
            surf.blit(BALL_IMG, BALL_IMG.get_rect(center=(int(self.x), int(self.y))))
        else:
            pygame.draw.circle(surf, WHITE, (int(self.x), int(self.y)), self.r)

class Player:
    def __init__(self, x, color, controls, image=None):
        self.x = x
        self.y = GROUND_Y - 40
        self.vx = self.vy = 0.0
        self.head_radius = 23
        self.color = color
        self.speed = 5.0
        self.on_ground = True
        self.facing = 1
        self.controls = controls
        self.score = 0
        self.kick_cooldown = 0
        self.image = image
        self.kick_timer = 0
        self.kick_duration = 12
        self.front_leg_scale = 4.8
        
        if self.color == BLUE:
            self.left_leg_img = PLAYER_BLUE_LEG_LEFT
            self.right_leg_img = PLAYER_BLUE_LEG_RIGHT
        else:
            self.left_leg_img = PLAYER_RED_LEG_LEFT
            self.right_leg_img = PLAYER_RED_LEG_RIGHT

    def update(self, keys):
        if keys[self.controls['left']]:
            self.vx = -self.speed
            self.facing = -1
        elif keys[self.controls['right']]:
            self.vx = self.speed
            self.facing = 1
        else:
            self.vx *= 0.85

        if keys[self.controls['jump']] and self.on_ground:
            self.vy = -14.5
            self.on_ground = False

        self.vy += GRAVITY * 0.9
        self.x += self.vx
        self.y += self.vy

        if self.y + self.head_radius > GROUND_Y:
            self.y = GROUND_Y - self.head_radius
            self.vy = 0.0
            self.on_ground = True

        self.x = max(10, min(WIDTH - 10, self.x))

        if self.kick_cooldown > 0: self.kick_cooldown -= 1
        if self.kick_timer > 0: self.kick_timer -= 1

    def draw(self, surf):
        if self.image:
            img = pygame.transform.flip(self.image, True, False) if self.facing == -1 else self.image
            rect = img.get_rect(midbottom=(int(self.x), int(self.y + self.head_radius)))
            surf.blit(img, rect)

            hip_x, hip_y = rect.centerx, rect.bottom - int(self.head_radius * 0.2)
            front_img = self.right_leg_img if self.facing == 1 else self.left_leg_img
            
            ang_total = -math.sin(((self.kick_duration - self.kick_timer) / self.kick_duration) * math.pi) * 90 if self.kick_timer > 0 else 0

            if front_img:
                img_blit = pygame.transform.flip(front_img, True, False) if self.facing == -1 else front_img
                rot = pygame.transform.rotozoom(img_blit, -ang_total * self.facing, self.front_leg_scale)
                surf.blit(rot, rot.get_rect(center=(hip_x + (self.head_radius * 0.95) * self.facing, hip_y)))
        else:
            pygame.draw.circle(surf, self.color, (int(self.x), int(self.y)), self.head_radius)

    def try_kick(self, ball, keys, kick_type='kick'):
        if kick_type in self.controls and keys[self.controls[kick_type]] and self.kick_cooldown == 0:
            dx, dy = ball.x - self.x, ball.y - self.y
            dist = math.hypot(dx, dy)
            if dist < self.head_radius + ball.r + 15:
                self.kick_timer, self.kick_cooldown = self.kick_duration, 18
                force = 16.0 if kick_type == 'lob' else 18.0
                nx, ny = dx / (dist + 1e-6), dy / (dist + 1e-6)
                ball.vx += nx * force + self.facing * (2.0 if kick_type == 'lob' else 4.0)
                ball.vy += ny * force - (16.0 if kick_type == 'lob' else 3.0)

    def try_headbutt(self, ball, keys, kick_type='kick'):
        if kick_type in self.controls and keys[self.controls[kick_type]]:
            dx, dy = ball.x - self.x, ball.y - (self.y - self.head_radius * 0.5)
            dist = math.hypot(dx, dy)
            if dy < -5 and dist < self.head_radius + ball.r + 12 and self.kick_cooldown == 0:
                self.kick_timer, self.kick_cooldown = self.kick_duration, 18
                force = 17.0
                nx, ny = dx / (dist + 1e-6), dy / (dist + 1e-6)
                ball.vx += nx * force + self.facing * 3.0
                ball.vy += ny * force - (10.0 if kick_type == 'lob' else 5.0)

# ------ Funções Utilitárias ------
def circle_collision(player, ball):
    dx, dy = ball.x - player.x, ball.y - (player.y - player.head_radius * 0.7)
    dist = math.hypot(dx, dy)
    min_dist = player.head_radius + ball.r
    if dist < min_dist and dist > 0.1:
        nx, ny = dx / dist, dy / dist
        ball.x += nx * (min_dist - dist + 5)
        ball.y += ny * (min_dist - dist + 5)
        rel_vel = (ball.vx - player.vx) * nx + (ball.vy - player.vy) * ny
        if rel_vel < 0:
            impulse = -(1 + PLAYER_BOUNCE * 1.2) * rel_vel * 0.6
            ball.vx += impulse * nx
            ball.vy += impulse * ny

def check_goal(ball):
    if ball.x - ball.r <= 10 and GROUND_Y - 115 < ball.y < GROUND_Y: return 'right'
    if ball.x + ball.r >= WIDTH - 10 and GROUND_Y - 115 < ball.y < GROUND_Y: return 'left'
    return None

def reset_positions(ball, p1, p2):
    ball.x, ball.y = WIDTH // 2, HEIGHT // 2 - 30
    ball.vx, ball.vy = random.choice([-3, 3]), -4
    p1.x, p1.y = WIDTH * 0.25, GROUND_Y - p1.head_radius
    p2.x, p2.y = WIDTH * 0.75, GROUND_Y - p2.head_radius
    p1.vx = p1.vy = p2.vx = p2.vy = 0

# ------ Inicialização do Jogo ------
ball = Ball(WIDTH // 2, HEIGHT // 2 - 50)
controls_p1 = {'left': pygame.K_a, 'right': pygame.K_d, 'jump': pygame.K_w, 'kick': pygame.K_s, 'lob': pygame.K_x}
controls_p2 = {'left': pygame.K_LEFT, 'right': pygame.K_RIGHT, 'jump': pygame.K_UP, 'kick': pygame.K_DOWN, 'lob': pygame.K_m}

p1 = Player(WIDTH * 0.25, BLUE, controls_p1, image=PLAYER_BLUE_IMG)
p2 = Player(WIDTH * 0.75, RED, controls_p2, image=PLAYER_RED_IMG)

# ====== CHAMADA DA TELA INICIAL (DO ARQUIVO tela.py) ======
num_jogadores = tela.tela_inicial(screen, clock)  #

reset_positions(ball, p1, p2)

# ------ Loop Principal ------
running, paused, goal_cooldown = True, False, 0

while running:
    clock.tick(FPS)
    keys = pygame.key.get_pressed()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit(); sys.exit()
        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
            paused = not paused

    if not paused:
        p1.update(keys)
        p2.update(keys)
        ball.update()
        ball.check_stuck_between_players(p1, p2)
        circle_collision(p1, ball)
        circle_collision(p2, ball)
        
        for p in [p1, p2]:
            p.try_kick(ball, keys, 'kick')
            p.try_kick(ball, keys, 'lob')
            p.try_headbutt(ball, keys, 'kick')
            p.try_headbutt(ball, keys, 'lob')

        if goal_cooldown == 0:
            scorer = check_goal(ball)
            if scorer:
                if scorer == 'right': p2.score += 1
                else: p1.score += 1
                goal_cooldown = FPS * 3
                reset_positions(ball, p1, p2)
        else:
            goal_cooldown -= 1

    # Desenho do campo
    if bg_image: screen.blit(bg_image, (0, 0))
    else: screen.fill(GREEN)
    
    p1.draw(screen)
    p2.draw(screen)
    ball.draw(screen)
    
    score_txt = font.render(f"{p1.score}  -  {p2.score}", True, BLACK)
    screen.blit(score_txt, (WIDTH // 2 - score_txt.get_width() // 2, 18))
    
    if paused:
        p_txt = font.render("PAUSADO", True, BLACK)
        screen.blit(p_txt, (WIDTH // 2 - p_txt.get_width() // 2, HEIGHT // 2 - 20))

    if p1.score >= SCORE_TO_WIN or p2.score >= SCORE_TO_WIN:
        winner = "Azul" if p1.score > p2.score else "Vermelho"
        end_txt = font.render(f"{winner} venceu! Aperte ESC para sair.", True, BLACK)
        screen.blit(end_txt, (WIDTH // 2 - end_txt.get_width() // 2, HEIGHT // 2 + 40))
        pygame.display.flip()
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
                    pygame.quit(); sys.exit()

    pygame.display.flip()
