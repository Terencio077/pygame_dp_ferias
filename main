import pygame
import os
import sys
import math
import random
import tela 

WIDTH, HEIGHT = 1000, 600
FPS = 60
GROUND_Y = HEIGHT - 80
SCORE_TO_WIN = 5
GRAVITY = 0.9
FRICTION = 0.995
BALL_FRICTION = 0.999
BALL_BOUNCE = 0.65       
MAX_BALL_SPEED = 15.0    
PLAYER_BOUNCE = 0.15     
BALL_GRAVITY_MULT = 0.9  
BALL_TOP_MARGIN = 40     
WHITE, BLACK, GREEN, BLUE, RED = (255,255,255), (0,0,0), (40,180,60), (60,140,220), (220,60,60)

pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
clock = pygame.time.Clock()

# Fonte aumentada para 45
font = pygame.font.SysFont("Arial", 45)

def try_load_image(name):
    paths = [name, os.path.join('assets', name), os.path.join('assets_futebol', name)]
    for p in paths:
        try: return pygame.image.load(p)
        except: continue
    return None

_bg = try_load_image("plano de fundo.png")
bg_image = pygame.transform.scale(_bg, (WIDTH, HEIGHT)).convert() if _bg else None
if bg_image: GROUND_Y = HEIGHT - 20

_p_blue = try_load_image("Player Blu.png")
_p_red = try_load_image("Player Red.png")
PLAYER_BLUE_IMG = pygame.transform.scale(_p_blue.convert_alpha(), (int(_p_blue.get_width() * (88 / _p_blue.get_height())), 88)) if _p_blue else None
PLAYER_RED_IMG = pygame.transform.scale(_p_red.convert_alpha(), (int(_p_red.get_width() * (88 / _p_red.get_height())), 88)) if _p_red else None

PLAYER_BLUE_LEG_LEFT = try_load_image("Player blu left leg.png")
PLAYER_BLUE_LEG_RIGHT = try_load_image("Player blu right leg.png")
PLAYER_RED_LEG_LEFT = try_load_image("Player red left leg.png")
PLAYER_RED_LEG_RIGHT = pygame.transform.flip(PLAYER_RED_LEG_LEFT, True, False) if PLAYER_RED_LEG_LEFT else None

_ball = try_load_image("ball.png") or try_load_image("bola.png")
BALL_IMG = pygame.transform.smoothscale(_ball.convert_alpha(), (38, 38)) if _ball else None

class Ball:
    def __init__(self, x, y, r=18):
        self.x, self.y, self.r, self.vx, self.vy = x, y, r, 0.0, 0.0
    def update(self):
        self.vy += GRAVITY * BALL_GRAVITY_MULT
        self.x += self.vx
        self.y += self.vy
        if self.y + self.r > GROUND_Y:
            self.y, self.vy = GROUND_Y - self.r, -abs(self.vy) * BALL_BOUNCE
            self.vx *= BALL_FRICTION
        if self.x - self.r < 0 or self.x + self.r > WIDTH:
            self.vx, self.x = -abs(self.vx) * 0.8 if self.x + self.r > WIDTH else abs(self.vx) * 0.8, self.r if self.x - self.r < 0 else WIDTH - self.r
        crossbar_y = GROUND_Y - 110
        if (self.y - self.r <= crossbar_y) and (self.x < 160 or self.x > WIDTH - 160):
            self.y, self.vy = crossbar_y + self.r, abs(self.vy) * BALL_BOUNCE * 1.2
            self.vx *= 0.75
        speed = math.hypot(self.vx, self.vy)
        if speed > MAX_BALL_SPEED:
            self.vx *= MAX_BALL_SPEED / speed
            self.vy *= MAX_BALL_SPEED / speed
    def check_stuck_between_players(self, p1, p2):
        if min(p1.x, p2.x) < self.x < max(p1.x, p2.x) and abs(self.x - p1.x) < 53 and abs(self.x - p2.x) < 53:
            self.y, self.vy, self.vx = min(p1.y, p2.y) - 60, -25.0, (8.0 if random.random() > 0.5 else -8.0)
    def draw(self, surf):
        if BALL_IMG: surf.blit(BALL_IMG, BALL_IMG.get_rect(center=(int(self.x), int(self.y))))
        else: pygame.draw.circle(surf, WHITE, (int(self.x), int(self.y)), self.r)

class Player:
    def __init__(self, x, color, controls, image=None):
        self.x, self.y, self.color, self.controls, self.image = x, GROUND_Y - 40, color, controls, image
        self.vx, self.vy, self.head_radius, self.speed, self.on_ground, self.facing, self.score = 0.0, 0.0, 23, 5.0, True, 1, 0
        self.kick_cooldown, self.kick_timer, self.kick_duration, self.front_leg_scale = 0, 0, 12, 4.8
        self.left_leg_img = PLAYER_BLUE_LEG_LEFT if color == BLUE else PLAYER_RED_LEG_LEFT
        self.right_leg_img = PLAYER_BLUE_LEG_RIGHT if color == BLUE else PLAYER_RED_LEG_RIGHT
    def update(self, keys):
        if keys[self.controls['left']]: self.vx, self.facing = -self.speed, -1
        elif keys[self.controls['right']]: self.vx, self.facing = self.speed, 1
        else: self.vx *= 0.85
        if keys[self.controls['jump']] and self.on_ground: self.vy, self.on_ground = -14.5, False
        self.vy += GRAVITY * 0.9
        self.x, self.y = self.x + self.vx, self.y + self.vy
        if self.y + self.head_radius > GROUND_Y: self.y, self.vy, self.on_ground = GROUND_Y - self.head_radius, 0.0, True
        self.x = max(10, min(WIDTH - 10, self.x))
        if self.kick_cooldown > 0: self.kick_cooldown -= 1
        if self.kick_timer > 0: self.kick_timer -= 1
    def draw(self, surf):
        if self.image:
            img = pygame.transform.flip(self.image, True, False) if self.facing == -1 else self.image
            rect = img.get_rect(midbottom=(int(self.x), int(self.y + self.head_radius)))
            surf.blit(img, rect)
            hip_x, hip_y = rect.centerx, rect.bottom - int(self.head_radius * 0.2)
            front_img = self.right_leg_img if self.facing == 1 else self.left_leg_img
            ang = -math.sin(((self.kick_duration - self.kick_timer) / self.kick_duration) * math.pi) * 90 if self.kick_timer > 0 else 0
            if front_img:
                img_blit = pygame.transform.flip(front_img, True, False) if self.facing == -1 else front_img
                rot = pygame.transform.rotozoom(img_blit, -ang * self.facing, self.front_leg_scale)
                surf.blit(rot, rot.get_rect(center=(hip_x + (self.head_radius * 0.95) * self.facing, hip_y)))
        else: pygame.draw.circle(surf, self.color, (int(self.x), int(self.y)), self.head_radius)
    def try_kick(self, ball, keys, k_type='kick'):
        if k_type in self.controls and keys[self.controls[k_type]] and self.kick_cooldown == 0:
            self.kick_timer, self.kick_cooldown = self.kick_duration, 12
            dx, dy, dist = ball.x - self.x, ball.y - self.y, math.hypot(ball.x - self.x, ball.y - self.y)
            if dist < self.head_radius + ball.r + 20: 
                f = 16.0 if k_type == 'lob' else 18.0
                ball.vx += (dx/(dist+1e-6)) * f + self.facing * (2.0 if k_type == 'lob' else 4.0)
                ball.vy += (dy/(dist+1e-6)) * f - (16.0 if k_type == 'lob' else 3.0)

def circle_collision(p, b):
    dx, dy, dist = b.x - p.x, b.y - (p.y - p.head_radius * 0.7), math.hypot(b.x - p.x, b.y - (p.y - p.head_radius * 0.7))
    if dist < p.head_radius + b.r and dist > 0.1:
        nx, ny = dx/dist, dy/dist
        b.x, b.y = b.x + nx*(p.head_radius + b.r - dist + 5), b.y + ny*(p.head_radius + b.r - dist + 5)
        rv = (b.vx - p.vx)*nx + (b.vy - p.vy)*ny
        if rv < 0:
            imp = -(1 + PLAYER_BOUNCE * 1.2) * rv * 0.6
            b.vx, b.vy = b.vx + imp*nx, b.vy + imp*ny

def reset_positions(ball, p1, p2):
    ball.x, ball.y, ball.vx, ball.vy = WIDTH//2, HEIGHT//2-30, random.choice([-3, 3]), -4
    p1.x, p1.y, p2.x, p2.y = WIDTH*0.25, GROUND_Y-p1.head_radius, WIDTH*0.75, GROUND_Y-p2.head_radius
    p1.vx = p1.vy = p2.vx = p2.vy = 0

ball = Ball(WIDTH // 2, HEIGHT // 2 - 50)
p1 = Player(WIDTH*0.25, BLUE, {'left':pygame.K_a,'right':pygame.K_d,'jump':pygame.K_w,'kick':pygame.K_s,'lob':pygame.K_x}, PLAYER_BLUE_IMG)
p2 = Player(WIDTH*0.75, RED, {'left':pygame.K_LEFT,'right':pygame.K_RIGHT,'jump':pygame.K_UP,'kick':pygame.K_DOWN,'lob':pygame.K_m}, PLAYER_RED_IMG)

tela.tela_inicial(screen, clock)
reset_positions(ball, p1, p2)
running, paused, goal_cooldown = True, False, 0

while running:
    clock.tick(FPS)
    for event in pygame.event.get():
        if event.type == pygame.QUIT: pygame.quit(); sys.exit()
        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE: paused = not paused
    if not paused:
        keys = pygame.key.get_pressed()
        p1.update(keys); p2.update(keys); ball.update()
        ball.check_stuck_between_players(p1, p2); circle_collision(p1, ball); circle_collision(p2, ball)
        for p in [p1, p2]:
            p.try_kick(ball, keys, 'kick'); p.try_kick(ball, keys, 'lob')
        if goal_cooldown == 0:
            if ball.x - ball.r <= 10 and 485 < ball.y < GROUND_Y: p2.score += 1; goal_cooldown = FPS * 3; reset_positions(ball, p1, p2)
            elif ball.x + ball.r >= WIDTH - 10 and 485 < ball.y < GROUND_Y: p1.score += 1; goal_cooldown = FPS * 3; reset_positions(ball, p1, p2)
        else: goal_cooldown -= 1
    
    screen.blit(bg_image, (0, 0)) if bg_image else screen.fill(GREEN)
    p1.draw(screen); p2.draw(screen); ball.draw(screen)

    score_txt = font.render(f"{p1.score}  -  {p2.score}", True, WHITE)
    screen.blit(score_txt, (WIDTH // 2 - score_txt.get_width() // 2, 18))

    # TEXTO PAUSADO COM MESMO TAMANHO E COR DO PLACAR
    if paused:
        p_txt = font.render("PAUSADO", True, WHITE)
        screen.blit(p_txt, (WIDTH // 2 - p_txt.get_width() // 2, HEIGHT // 2 - p_txt.get_height() // 2))
    
    if p1.score >= SCORE_TO_WIN or p2.score >= SCORE_TO_WIN:
        winner = "Azul" if p1.score >= SCORE_TO_WIN else "Vermelho"
        if tela.tela_vitoria(screen, clock, winner) == "REINICIAR":
            p1.score = p2.score = 0
            reset_positions(ball, p1, p2)
        else: running = False
    pygame.display.flip()